<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Your Name">
<meta name="dcterms.date" content="2026-01-14">
<meta name="description" content="A short summary of what this post is about.">

<title>My New Analysis – lab2_datascience_blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-bc185b5c5bdbcb35c2eb49d8a876ef70.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-1ddaa63cc98d7b260f5cf9c9021de554.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">lab2_datascience_blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">William Song</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">My New Analysis</h1>
                  <div>
        <div class="description">
          A short summary of what this post is about.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">code</div>
                <div class="quarto-category">analysis</div>
                <div class="quarto-category">python</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Your Name </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 14, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Retention rate is one of the major KPI metrics in many businesses. The concept isn’t too complicated, but it involves many details and is important for understanding how your business performs. It is also a prerequisite for calculating Customer Lifetime Value, known as CLV or LTV. In this long post, I will split the content into three sections: Evaluation Steps, Charts, and SQL Code. Hopefully this structure will make it easier for readers to digest.</p>
</section>
<section id="evaluation-steps" class="level2">
<h2 class="anchored" data-anchor-id="evaluation-steps">Evaluation Steps</h2>
<p>The major steps are as follows: - Step 1 Identify the “cohort.” A cohort could be a group of people who made purchases through the same marketing campaign or event, or a group of people who subscribed to a service within a certain time period (e.g., the same day or the same month).</p>
<p>Depending on your business, the challenge is that people in different cohorts have different purchasing or revisiting cycles, so defining your cohort is an important first step. Usually, cohorts are either event‑based or time‑based, but sometimes additional categorical variables are added to narrow down the groups. Keep in mind that the more variables you include, the more complex the SQL code and results will become.</p>
<p>Using the gaming industry as an example, we usually use player signup date as the cohort base (time‑based). Each day, a number of people join the game, and each day becomes a different cohort. Retention rate is evaluated day by day. It is also possible to add other variables—for example, which countries the cohorts belong to, which marketing campaigns they came from, or whether they are payers or non‑payers. These additional variables make the SQL code more complex to write and read. (I will explain this later in the SQL section.)</p>
<ul>
<li>Step 2 Understand the math formula, which is straightforward:</li>
</ul>
<p>Retention&nbsp;Rate = ( number of&nbsp;people&nbsp;in&nbsp;the&nbsp;same&nbsp;cohort&nbsp;who&nbsp;revisited&nbsp;during&nbsp;the&nbsp;period / number of&nbsp;people&nbsp;in&nbsp;the&nbsp;same&nbsp;cohort&nbsp;at&nbsp;the&nbsp;start&nbsp;of&nbsp;the&nbsp;period) × 100</p>
<p>Although the formula is simple, the challenge is calculating the rate for each cohort from its initial day through each of its future days. For example, on July 1st, we have 100 people joining the business, usually labeled as day‑1. (Note that some people use day‑0 for the very first day, which is assumed to have a 100% rate as the base. This is often omitted in charts. If you see a day‑1 value below 100% in someone else’s work, it usually means they used day‑0 as the starting label. It’s a personal preference; I prefer day‑1.)</p>
<p>On the following day, July 2nd, 50 people from the same cohort revisit. This is labeled as day‑2, and the retention rate is 50/100 = 50%.</p>
<p>On July 3rd, 20 people revisit, labeled as day‑3, giving a retention rate of 20/100 = 20%. And so on for future days. Keep in mind that this is always referring to the same cohort that joined on July 1st. A new cohort joins on July 2nd, and July 3rd becomes that cohort’s day‑2, and so forth. As each new day is added, the volume of data and calculations increases quickly.</p>
<p>By the way, “churn rate” is the reverse of retention rate, calculated as:</p>
<p>Churn&nbsp;Rate = 1 − Retention&nbsp;Rate</p>
<p>Churn rate is another common term you will encounter when working with retention metrics.</p>
<ul>
<li>Step 3 From the results in Step 2, we can use visualization tools to create charts. In my experience, retention charts are not easy to interpret at first glance. You will need practice to get used to them, and you will often need to teach stakeholders how to read them as well. There are three major chart types commonly used to display retention rate. All three are popular, but each has its downsides, which I will demonstrate below.</li>
</ul>
</section>
<section id="charts" class="level2">
<h2 class="anchored" data-anchor-id="charts">Charts</h2>
<p><img src="path/to/your/image.png" class="img-fluid" alt="Caption text"> Source: https://help.peelinsights.com/docs/retention-rate-vs-repurchase-rate-1</p>
<p>Based on the calculation in Step 2, the first popular chart (above) is a stair‑like tabular chart. Each row represents a cohort, and each column and value represents the retention rate for each subsequent day or period. Heat‑map colours are usually applied to make the numbers easier to read; without them, the table can look cluttered due to the volume of data.</p>
<p><img src="path/to/your/image.png" class="img-fluid" alt="Caption text"> Source: https://segment.com/growth-center/customer-retention/rate/</p>
<p>The second chart (above) is a downward‑sloping line chart derived from the tabular format. Each line represents a cohort and its retention rate across each following day or defined period. Note that in this example, cohorts are defined by app genre (event‑based) rather than by join date. This highlights the importance of clearly defining your cohort before running the analysis. The downside of this chart is that as more cohorts accumulate, the number of lines increases and they begin to overlap, making the chart difficult to interpret. This is where the third chart becomes useful.</p>
<p><img src="path/to/your/image.png" class="img-fluid" alt="Caption text"> Source: https://www.linkedin.com/pulse/how-measure-retention-173tech/</p>
<p>The third chart (above) provides insight into long‑term performance based on the day‑n line selected in the visualization design. I personally prefer this chart when presenting retention information to stakeholders. Each line represents a specific day‑n metric. For example, the blue line is Day‑1, the red line (Week 1) is Day‑7, and the green line (Month 1) is Day‑30. The blue line shows Day‑1 retention rates across different cohorts. Vertically, each point on the x‑axis corresponds to a cohort. Using 2020–03 as an example, the blue point at roughly 80% represents its Day‑1 retention rate, the red point at about 65% represents its Day‑7 rate, and the green point at about 55% represents its Day‑30 rate. In other words, the vertical stack of points for a given cohort shows its retention performance across different time intervals.</p>
<p>From this chart, we can reasonably conclude that the 2020–03 cohort is healthier than earlier cohorts (from 2019–07 to 2020–02), as it shows stronger Day‑1, Day‑7, and Day‑30 retention. The main challenge with this chart is that reading cohorts vertically can feel unintuitive at first. However, once you get used to it, it becomes a very effective way to compare retention performance across cohorts.</p>
</section>
<section id="sql-written-in-google-bigquery-environment" class="level2">
<h2 class="anchored" data-anchor-id="sql-written-in-google-bigquery-environment">SQL (Written in Google BigQuery Environment)</h2>
<p>I usually structure the SQL queries into two sections. Section 1 builds the base table that contains all necessary variables, and this table is typically saved as a temporary table for later use. This allows me to experiment with different query setups in Section 2 without rerunning the Section 1 queries and consuming unnecessary read resources. However, if you already know exactly what you need, you can combine the queries from all sections into a single script.</p>
<section id="section-1" class="level3">
<h3 class="anchored" data-anchor-id="section-1">Section 1</h3>
<pre><code>-- save the result to a table for later use
truncate table `mid_retention_data`;
insert into `mid_retention_data`

with join_date as (
-- find out each user's first join date, more variables add complexity
-- each user should have 1 row only
    select user_id
        , user_join_date
-- you can add all potential categorical variables first
-- then in Section2, you are free to select desired ones only
        , case
            when campaign_id in (123, 456, 789) then 'special'
            when campaign_id in (100, 200) then 'organic'
            else 'regular'
          end as campaign_type
        , case 
            when country = 'KR' then 'korea'
            when country = 'JP' then 'japan'
            when country = 'US' then 'us'
            else 'others'
          end as country_others_vs_tier1
        , case 
            when all_iap_amount &gt; 0 then 'payer'
            else 'non_payer'
          end as payer_flag
    from `user_metric_table`
)
, log_date as (
-- find out each user's all login dates
-- eg// a user visits and revisits for 30 days then there are 30 rows
-- the table size will be large if long period and millions of users
    select distinct user_id
        , login_date
    from `user_login_data`
)
-- join two tables together and calculate the period apart
-- between each login date and first date
select distinct b.user_id
    , b.user_join_date
    , b.campaign_type
    , b.country_others_vs_tier1
    , b.payer_flag
    , a.login_date
-- their first login date should be the same as join date
-- use date_diff() to calculate day-n information
-- + 1 or not depends on you want the first day as 0 or 1, and I prefer 1
    , date_diff(a.login_date, b.user_join_date, day) + 1 as day_num
from log_date as a
inner join join_date as b on a.user_id = b.user_id
-- we can use order by to briefly check if results meet expectation
-- order by b.user_id, a.login_date
;</code></pre>
<p>I have added additional variables such as campaign_type, country, and payer_flag. These will increase the complexity in the following sections. However, because the results are saved to a middle table, I can include as many potentially useful categorical variables as needed and choose only the relevant ones in Section 2. At this stage, after running the short set of queries below, you could technically export the data to visualization tools like Tableau or Power BI—but there is a pitfall to be aware of.</p>
</section>
<section id="section-2" class="level3">
<h3 class="anchored" data-anchor-id="section-2">Section 2</h3>
<pre><code>with base_table as (
    select distinct user_id
        , user_join_date -- represent cohorts
-- say I stored 10 additional categorical variables in the middle table
-- I can only select fewer variables here depending on goals.
        , campaign_type
        , country_others_vs_tier1
        , payer_flag
        , day_num
    from `mid_retention_data` -- saved middle table from Secion1
)
, data_per_day as (
    select user_join_date-- represent cohorts
        , campaign_type
        , country_others_vs_tier1
        , payer_flag
-- add or remove day_n based on your requirements in lines below
-- these calculate the retained user counts on day_n for each cohort
-- day_1 is the first day for each cohort
        , sum(case when day_num = 1 then 1 else 0 end) as day_1
        , sum(case when day_num = 2 then 1 else 0 end) as day_2
        , sum(case when day_num = 3 then 1 else 0 end) as day_3
        , sum(case when day_num = 4 then 1 else 0 end) as day_4
        , sum(case when day_num = 5 then 1 else 0 end) as day_5
        , sum(case when day_num = 6 then 1 else 0 end) as day_6
        , sum(case when day_num = 7 then 1 else 0 end) as day_7
        , sum(case when day_num = 14 then 1 else 0 end) as day_14
        , sum(case when day_num = 30 then 1 else 0 end) as day_30
        , sum(case when day_num = 90 then 1 else 0 end) as day_90
        , sum(case when day_num = 183 then 1 else 0 end) as day_183
        , sum(case when day_num = 365 then 1 else 0 end) as day_365
    from base_table 
    group by user_join_date, campaign_type, country_others_vs_tier1, payer_flag
)
, result_data as (
    SELECT user_join_date
        , campaign_type
        , country_others_vs_tier1
        , payer_flag
        , CASE WHEN day_1 IS NOT NULL THEN day_1 ELSE 0 END as d1
-- add or remove dn based on your requirements in lines below
-- these calculate the retention rate on dn for each cohort
-- day_1 is the denominator for following days (retention rate formula)
        , CASE WHEN day_1 IS NOT NULL THEN 
            SAFE_DIVIDE(day_2, day_1) ELSE 0 END as d2
        , CASE WHEN day_1 IS NOT NULL THEN 
            SAFE_DIVIDE(day_3, day_1) ELSE 0 END as d3
        , CASE WHEN day_1 IS NOT NULL THEN 
            SAFE_DIVIDE(day_4, day_1) ELSE 0 END as d4
        , CASE WHEN day_1 IS NOT NULL THEN 
            SAFE_DIVIDE(day_5, day_1) ELSE 0 END as d5
        , CASE WHEN day_1 IS NOT NULL THEN 
            SAFE_DIVIDE(day_6, day_1) ELSE 0 END as d6
        , CASE WHEN day_1 IS NOT NULL THEN 
            SAFE_DIVIDE(day_7, day_1) ELSE 0 END as d7
        , CASE WHEN day_1 IS NOT NULL THEN 
            SAFE_DIVIDE(day_14, day_1) ELSE 0 END as d14
        , CASE WHEN day_1 IS NOT NULL THEN 
            SAFE_DIVIDE(day_30, day_1) ELSE 0 END as d30
        , CASE WHEN day_1 IS NOT NULL THEN 
            SAFE_DIVIDE(day_90, day_1) ELSE 0 END as d90
        , CASE WHEN day_1 IS NOT NULL THEN 
            SAFE_DIVIDE(day_183, day_1) ELSE 0 END as d183
        , CASE WHEN day_1 IS NOT NULL THEN 
            SAFE_DIVIDE(day_365, day_1) ELSE 0 END as d365
    FROM data_per_day
)
-- unpivot is for viz design so we can use retained_days as filter
-- try it yourself with and without unpivot and you will understand why
SELECT user_join_date
    , campaign_type
    , country_others_vs_tier1
    , payer_flag
    , d1 as new_user_count
    , retained_days
    , retention_rate
FROM result_data
unpivot
(
    retention_rate
    for retained_days in (d2, d3, d4, d5, d6, d7, d14, d30, d90, d183, d365)
) unpiv
;</code></pre>
</section>
<section id="in-section-2-here-are-the-key-points-to-pay-attention-to" class="level3">
<h3 class="anchored" data-anchor-id="in-section-2-here-are-the-key-points-to-pay-attention-to">In Section 2, here are the key points to pay attention to:</h3>
<ol type="1">
<li><p>Although it requires some manual work, you can add or remove specific day numbers in the analysis. Common practice includes using d2, d3, d7, d14, d30, d90, half‑year, or full‑year metrics, depending on your business requirements. This is also why Section 2 is less flexible than Section 1. For example, if a stakeholder asks you to display the Day‑17 metric, you would need to add a new line to the query and re‑run both the queries and the visuals. Fortunately, such requests are extremely rare.</p></li>
<li><p>The data_per_day and result_data tables in Section 2 form the backbone of the stair‑like tabular chart shown earlier. The unpivot process helps you create the second and third line charts by using retained_days as a filter in your visualization tool. Try building your visuals with and without the unpivot step—you’ll quickly see why including it makes the design much more convenient.</p></li>
<li><p>In the Complex Version of Section 2, the more variables you include, the more challenging it becomes to organize your visualizations. Typically, we compare one or two variables (three in my example). Adding more variables can make the charts confusing and harder to interpret.</p></li>
</ol>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>I hope these points help you analyze retention rate more effectively. I recommend testing with your own data—you’ll gain a much clearer understanding when working with your specific use case.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>